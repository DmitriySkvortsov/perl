# Репозиторий с решением задачек по Perl

## Задание 1

1. написать скрипт, который будет принимать на вход из командной строки один параметр - имя пользователя (user_name).
2. Внутри скрипта нужно объявить массив с именами пользователей .
3. Запустить твой скрипт, передав туда в качестве параметра имя пользователя из объявленного тобой массива.
4. Принять переданный параметр в переменную с помощью дескриптора стандартного ввода <STDIN>.
И, если такой пользователь в массиве - есть, вывести на экран сообщение "Добро пожаловать, $user_name !",
а если такого пользователя нет - вывести на экран сообщение "Ты кто такой, $user_name?!".

### decision
#### latinnames.pl

## Задание 2

Доработать скрипт из задания Task_1:

1. Принять один параметр через @ARGV и просто принтануть его на экран(это метод просто проверяем и комментируем код).
2. Принять имя пользователя $user_name и его пароль $user_passwd через %ENV. 
 2.1 Далее проверить, есть ли пользователь в массиве(это уже есть) и если пользователь найден, поприветствовать его `Добро пожаловать '$user_name'!` и вывести его пароль на экран `Твой пароль $user_passwd`.

Для приема параметров используются 2 способа:

1. Через массив @ARGV
Просто при запуске скрипта, после его имени, напишите параметр
`>my_script.pl ваше_имя`
В итоге "ваше_имя" станет доступным в нулевом индексе массива @ARGV(вы ведь уже прочитали, что нумерация массивов идет с нуля)
Далее просто присваиваем его в переменную:
`my $user_name = $ARGV[0];` $ARGV идет со знаком доллара, т.к. мы обращаемся к конкретному элементу массива, а он является скаляром.
2. Через хэш %ENV
Хэш - ассоциативный массив. В котором есть ключ и значение.

### decision
#### env_name.pl

## Задание 3

Заменить массив на хэш.
Вам необходимо заменить массив @users_list на хэш %users_prms в котором в качестве ключа используется имя пользователя, а в качестве значения - его пароль. Далее проверить, что в хэше есть ключ с именем пользователя и если он есть, и пароль подходит, то вывести сообщение `Добро пожаловать '$user_name'!`, а если пользователь не найден, или пароль не подходит, вывести сообщение `Неверный логин или пароль.`

### decision
#### namePass.pl

## Задание 4

1. Вынести проверку пользователя в отдельную ф-цию _login у которой на входе 2 параметра:
  1 - user_name
  2 - user_password
 На выходе число:
  0 - пользователь прошел проверку
  -1(минус один) - пользователь не прошел проверку
2. Внутри ф-ции проверить пароль пользователя(это мы уже делали в предыдущем задании)
3. Приняв ответ функции, мы его проверяем и выводим наши сообщения в зависимости от того, что вернула ф-ция(0 - хорошо, все_остальное - плохо).
4. Принимая параметры из %ENV, вы можете ничего не получить на вход, а лучший патерн гласит: мусор на входе - ошибка на выходе. Проверьте, что входные параметры не пустые и если что, выходите их скрипта с сообщениями об ошибке "Не указано имя пользователя" и "Не указан пароль"

### decision
#### subNameEnv.pl

## Задание 5

Создать новый файл сonf.ini в вашем проекте
В файл добавить аналогичный хеш только в формате name=password т.е. получится так:
alex=1234
nic=2345
и т.д.
Создать ф-цию _read_conf
Ф-ция должна прочитать файл в массив и вернуть его.

### decision
#### conf.ini   &&   _read_conf.pl

## Задание 6

Модифицировать ф-цию read_conf, чтобы она вернула не массив, а хэш.

1. Сразу облегчим себе жизнь и с помощью РВ заменим все пробелы на пустоту.
2. Разбив строку на ключ и значение, нужно их проверить на true и если хоть один из них пустой, в хэш эта пара не попадает(ругаться на это не нужно просто пропускаем строку и идем к следующей)
3. Вишенка на торте. Если видели конфигурационный файл crontab(служба запускающая скрипты по расписанию) то могли заметить, что некоторые задания закомментированы символом #. Это значит, что его приостановили на неопределенный срок и crontab его игнорирует. Так вот давайте сделаем это и в нашем конфиге. Если первый симвом #, то пропускаем строку. Делаете это опять же с помощью РВ.
4. После написание ф-ции замените хэш из ф-ции _check_user на хэш полученный из файла.

## Задание 7

Вынести внутренние функции в отдельный модуль ( с расширением .pm ).

1. Создать файл tools.pm в той же директории, где лежит ваш скрипт;
2. Перенести туда свои внутренние функции по одной, добившись в итоге работоспособности кода с использованием этого нового модуля;
3. Путь до конфигурационного файла определить в начале так our $conf_path = '/full_path_to_file/conf.ini';

### decision
#### TOOLS.pm and env_task_logins.pl

## Задание 8

Добавить в скрипт возможность регистрации нового пользователя в системе. Делаем это через добавление нового входного параметра.
Добавляем новый входной параметр - "action" с возможными значениями log и reg.
В случае, если передан log вызывается ф-ция tools::login и на этом работа заканчивается.
В случае, если передан reg, то вызывается новая ф-ция tools::reg_user которая считывает наш конфиг(такая ф-ция уже есть и она возвращает хэш) и проверяет, был ли пользователь зарегистрирован ранее. Если да, то нужно отписать, что "Пользователь с таким логином уже зарегистрирован", а если нет, то нужно добавить его в хэш
и вызвать новую ф-цию tools::rewrite_config которая преобразует хэш в текст и перезапишет файл.
Обязательно проверьте новый параметр action на валидность. В нем может быть или reg или log. В противном случае выводим ошибку и завершаем работу скрипта.

### decision
#### TOOLS.pm and env_task_logins.pl


## Задание 9

Проверить входные параметры user_name и password на валидность. Необходимо:

1. написать отдельную ф-цию tools::check_user_name которая проверит что логин:
  1.1 начинается с буквы
  1.2 может содержать цифры
  1.3 не содержит спецсимволов короме знака тире и нижнего подчеркивания
  1.4 заканчивается на цифру или букву
  1.5 не содержит кириллицу

2. написать отдельную ф-цию tools::check_user_passwd которая проверит, что пароль:
  2.1 не меньше 8 символов
  2.2 начинается с латинской буквы
  2.3 содержит минимум один спецсимвол из списка !@#$%^&*()
  2.4 содержит минимум один символ в верхнем регистре
  2.5 содержит минимум одну цифру

3. Вызвать указанные ф-ции перед регистрацией нового пользователя tools::reg_user в самом скрипте back_end.pl

### decision
#### TOOLS.pm and env_task_logins.pl

## Задание 10

Перезапись файла.
Добавить возможность удаления пользователя.
К нашим 2 действиям reg и log нужно добавить третье del. В результате, при передаче параметров user_name=Sergey action=del ./your_script.pl пользователь Sergey должен быть удален из конфигурационного файла.
В итоге появится новая ф-ция tools::del_user - которая принимает в себя имя пользователя, и по аналогии с ф-цией tools::reg_user получив хэш, удаляет из него один элемент и передает ф-ции tools::rewrite_config

### decision
#### TOOLS.pm and env_task_logins.pl

## Задание 11

Поменять пользователю пароль.
Добавить еще одно дейсвтие в action - change_passwd.
Приняв его вызываем одноименную ф-цию tools::change_passwd передав на вход $user_name и $user_passwd. В ф-ции проверяем наличие пользователя и, если пользователь есть, уже проверенным механизмом переписывания хэша меняем содержимое файла.
Не забывайте, что новый пароль должен соответствовать требованиям сложности как в задаче №9

### decision
#### TOOLS.pm and env_task_logins.pl

## Задание 12

Добавить описание вызова скрипта.
У всех пакетных скриптов linux есть опция -h которая вызывает help по скрипту и подробно описывает возможноси его работы. Давайте сделаем аналогично и в нашем скрипте. Если скрипт вызван без параметров совсем, #либо недостает одного параметра#, то выводится сообщение с внятным описанием по работе со скриптом.
######################################################
\#back_end.pl usage
\# action=reg user_name=NAME user_passwd=PASSWD ./back_end.pl - registaton new user in system;
\#action=log user_name=NAME user_passwd=PASSWD ./back_end.pl - login in system
\#action=del user_name=NAME ./back_end.pl - remove user from system
\#action=change_passwd user_name=NAME user_passwd=PASSWD ./back_end.pl - change user password
\######################################################

### decision
#### TOOLS.pm and env_task_logins.pl

## Задание 13

Написать тесты на модуль tools.pm
Полное покрытие достигается тогда, когда вы вызываете ф-цию так, чтобы выполнялось каждое условие(if, elsif, else), вызывался каждый return. Т.е. если ф-ция проверяет, что при отсутствии файла, возвращается ошибка, то при выполнении теста нужно воспроизвести недоступность файла(например изменив его права или переименовав). Но это в идеальном мире и перебарщивать тоже не стоит.
Тесты начинаются с use Test::More tests =>(число тестов);
Вот пример простого теста:
is(create_user($GOOD_USER), $RC_OK, 'create_user(user_name) OK');
is(create_user($WRONG_USER), $RC_ERROR, 'create_user(user_name) wrong name OK');
is(create_user(), $RC_ERROR, 'create_user() without input user_name OK');
В примере тестируется ф-ция create_user(). В первом тесте передаются правильные параметры и ф-ция возвращает хороший код. Во втором случае передается заведомо неправильный логин, чтобы проверить, что ф-ция вернула код ошибки. В третьем примере ф-ция вызывается без параметров вовсе тем самым проверяя, что разработчик предвидел подобный вариант и вернул код ошибки.
Покройте подобными тестами модуль tools.pm. Для этого в папке проекта создайте папку tests и в ней файл tools.t Расширение '.t' показывает, что это именно тест. Запускайте написанные тесты простым запуском perl tools.t из командной строки(в больших командах тесты запускаются автоматически при внесении изменений в репозиторий)


## Калькулятор
Написать калькулятор который принимает на вход 3 параметра : число, число, действие
Действия : plus , minus, mlt, divide

### decision
#### calca.pl

## Бесконечный Калькулятор
Написать калькулятор который будет продолжать спрашивать действия и число до выхода , режим ввода следующий ( цифра , знак операции, цифра) или польская запись
Для выхода из программы используется символ равно по завершении программы в консоль будет выведен результат

### decision
#### newCalc_infinit.pl

## Улиточка
В один банк, условно назовем его Банк Пеньков. Взяли на работу разработчика Улиточку, в отдел кодинга и эскюелинга, для помощи в разгребания технического долга в N задач. Известно, что скорость решения задач у Улиточки (a) задач в день. А скорость прилетающих в бэклог новых задач (b). И мы не уверены, что (a > b). А еще мы знаем, что спринт длится 2 недели. Т.е. 10 рабочих дней, ведь по субботам и воскресеньям Улиточка не работает, а занимается переездами и прочими личными делами. К счастью, остальные работники тоже, и в выходные в бэклог задачи не приходят.
Нужно написать скрипт, который скажет, через сколько спринтов Улиточка разгребет весь тех.долг, если разгребет, конечно.
Казалось бы, а что тут сложного и где звездочка задачи.
Нюанс в том, что это же Банк Пеньков, и разработчики тут не признают никаких if или циклов любых видов, так что решить задачу надо без них.
В итоге приняв на входе любым путем 3 числовых параметра, вывод на экран должен будет показать вывод по Улиточке: Не справится или Справится за (кол-во) спринтов.

### decision
#### snail_at_work.pl

## Чтото с памятью моей
Нужно написать программу, в интерфейсе которой вводятся последовательность цифр, окончанием ввод цифр будет ввод знака "."
После чего экран очищается. (опционально во время написания кода)
И пользователю задаются 3-5 вопросов (зависит от длины последовательности до 7 - 3 вопроса, до 11 - 4 вопроса, свыше 11 - 5 вопросов):
Какое число следовало за (некое случайное число из введенной последовательности) ?
Если длина последовательности меньше 6, игра не запускается, и сообщает о недостаточности для теста.
Если проверка случилась, то идет простая проверка каких ответов было больше, правильных или не правильных. И делается вывод, следует ли начать пить таблетки для памяти.

### decision
#### how_my_memory.pl
